/**
* @file aes.h
* @author Ђорђе Живановић
* @brief Фајл садржи функције за шифорвање и дешфировање датотека АЕС-ом.
*/
#define _CRT_SECURE_NO_DEPRECATE
#ifndef _aes_h_
#define _aes_h_
#include <stdio.h>  
typedef unsigned __int32 UInt32;  /** Ако unsigned int није 4 бита. */
typedef unsigned __int8 UChar;
#define NUM_ROW 4 /**< Број врста у једном блоку. */
#define STATE_SIZE 16 /**< Број бајтова у једном блоку */
#define CRYPT_TEXT ".crypt" /**< Екстензија криптоване датотеке. */
#define DIGIT_NUM 10 /**< Број цифара у декадном систему. */
#define MAX_FILE_PATH 260 /**< Максимална дужина путање у @c WINDOWS*/

static const UChar S_BOX[16][16] = {
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};
/**< Прерачунате вредности које користи функција SubByte. */

static const UChar INVS_BOX[16][16] = {
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
}; 
/**< Прерачунате вредности које користи функција InvSubByte */

static const UChar G_FIELD_MUL[256][6] = {
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x02, 0x03, 0x09, 0x0b, 0x0d, 0x0e },
	{ 0x04, 0x06, 0x12, 0x16, 0x1a, 0x1c }, { 0x06, 0x05, 0x1b, 0x1d, 0x17, 0x12 },
	{ 0x08, 0x0c, 0x24, 0x2c, 0x34, 0x38 }, { 0x0a, 0x0f, 0x2d, 0x27, 0x39, 0x36 },
	{ 0x0c, 0x0a, 0x36, 0x3a, 0x2e, 0x24 }, { 0x0e, 0x09, 0x3f, 0x31, 0x23, 0x2a },
	{ 0x10, 0x18, 0x48, 0x58, 0x68, 0x70 }, { 0x12, 0x1b, 0x41, 0x53, 0x65, 0x7e },
	{ 0x14, 0x1e, 0x5a, 0x4e, 0x72, 0x6c }, { 0x16, 0x1d, 0x53, 0x45, 0x7f, 0x62 },
	{ 0x18, 0x14, 0x6c, 0x74, 0x5c, 0x48 }, { 0x1a, 0x17, 0x65, 0x7f, 0x51, 0x46 },
	{ 0x1c, 0x12, 0x7e, 0x62, 0x46, 0x54 }, { 0x1e, 0x11, 0x77, 0x69, 0x4b, 0x5a },
	{ 0x20, 0x30, 0x90, 0xb0, 0xd0, 0xe0 }, { 0x22, 0x33, 0x99, 0xbb, 0xdd, 0xee },
	{ 0x24, 0x36, 0x82, 0xa6, 0xca, 0xfc }, { 0x26, 0x35, 0x8b, 0xad, 0xc7, 0xf2 },
	{ 0x28, 0x3c, 0xb4, 0x9c, 0xe4, 0xd8 }, { 0x2a, 0x3f, 0xbd, 0x97, 0xe9, 0xd6 },
	{ 0x2c, 0x3a, 0xa6, 0x8a, 0xfe, 0xc4 }, { 0x2e, 0x39, 0xaf, 0x81, 0xf3, 0xca },
	{ 0x30, 0x28, 0xd8, 0xe8, 0xb8, 0x90 }, { 0x32, 0x2b, 0xd1, 0xe3, 0xb5, 0x9e },
	{ 0x34, 0x2e, 0xca, 0xfe, 0xa2, 0x8c }, { 0x36, 0x2d, 0xc3, 0xf5, 0xaf, 0x82 },
	{ 0x38, 0x24, 0xfc, 0xc4, 0x8c, 0xa8 }, { 0x3a, 0x27, 0xf5, 0xcf, 0x81, 0xa6 },
	{ 0x3c, 0x22, 0xee, 0xd2, 0x96, 0xb4 }, { 0x3e, 0x21, 0xe7, 0xd9, 0x9b, 0xba },
	{ 0x40, 0x60, 0x3b, 0x7b, 0xbb, 0xdb }, { 0x42, 0x63, 0x32, 0x70, 0xb6, 0xd5 },
	{ 0x44, 0x66, 0x29, 0x6d, 0xa1, 0xc7 }, { 0x46, 0x65, 0x20, 0x66, 0xac, 0xc9 },
	{ 0x48, 0x6c, 0x1f, 0x57, 0x8f, 0xe3 }, { 0x4a, 0x6f, 0x16, 0x5c, 0x82, 0xed },
	{ 0x4c, 0x6a, 0x0d, 0x41, 0x95, 0xff }, { 0x4e, 0x69, 0x04, 0x4a, 0x98, 0xf1 },
	{ 0x50, 0x78, 0x73, 0x23, 0xd3, 0xab }, { 0x52, 0x7b, 0x7a, 0x28, 0xde, 0xa5 },
	{ 0x54, 0x7e, 0x61, 0x35, 0xc9, 0xb7 }, { 0x56, 0x7d, 0x68, 0x3e, 0xc4, 0xb9 },
	{ 0x58, 0x74, 0x57, 0x0f, 0xe7, 0x93 }, { 0x5a, 0x77, 0x5e, 0x04, 0xea, 0x9d },
	{ 0x5c, 0x72, 0x45, 0x19, 0xfd, 0x8f }, { 0x5e, 0x71, 0x4c, 0x12, 0xf0, 0x81 },
	{ 0x60, 0x50, 0xab, 0xcb, 0x6b, 0x3b }, { 0x62, 0x53, 0xa2, 0xc0, 0x66, 0x35 },
	{ 0x64, 0x56, 0xb9, 0xdd, 0x71, 0x27 }, { 0x66, 0x55, 0xb0, 0xd6, 0x7c, 0x29 },
	{ 0x68, 0x5c, 0x8f, 0xe7, 0x5f, 0x03 }, { 0x6a, 0x5f, 0x86, 0xec, 0x52, 0x0d },
	{ 0x6c, 0x5a, 0x9d, 0xf1, 0x45, 0x1f }, { 0x6e, 0x59, 0x94, 0xfa, 0x48, 0x11 },
	{ 0x70, 0x48, 0xe3, 0x93, 0x03, 0x4b }, { 0x72, 0x4b, 0xea, 0x98, 0x0e, 0x45 },
	{ 0x74, 0x4e, 0xf1, 0x85, 0x19, 0x57 }, { 0x76, 0x4d, 0xf8, 0x8e, 0x14, 0x59 },
	{ 0x78, 0x44, 0xc7, 0xbf, 0x37, 0x73 }, { 0x7a, 0x47, 0xce, 0xb4, 0x3a, 0x7d },
	{ 0x7c, 0x42, 0xd5, 0xa9, 0x2d, 0x6f }, { 0x7e, 0x41, 0xdc, 0xa2, 0x20, 0x61 },
	{ 0x80, 0xc0, 0x76, 0xf6, 0x6d, 0xad }, { 0x82, 0xc3, 0x7f, 0xfd, 0x60, 0xa3 },
	{ 0x84, 0xc6, 0x64, 0xe0, 0x77, 0xb1 }, { 0x86, 0xc5, 0x6d, 0xeb, 0x7a, 0xbf },
	{ 0x88, 0xcc, 0x52, 0xda, 0x59, 0x95 }, { 0x8a, 0xcf, 0x5b, 0xd1, 0x54, 0x9b },
	{ 0x8c, 0xca, 0x40, 0xcc, 0x43, 0x89 }, { 0x8e, 0xc9, 0x49, 0xc7, 0x4e, 0x87 },
	{ 0x90, 0xd8, 0x3e, 0xae, 0x05, 0xdd }, { 0x92, 0xdb, 0x37, 0xa5, 0x08, 0xd3 },
	{ 0x94, 0xde, 0x2c, 0xb8, 0x1f, 0xc1 }, { 0x96, 0xdd, 0x25, 0xb3, 0x12, 0xcf },
	{ 0x98, 0xd4, 0x1a, 0x82, 0x31, 0xe5 }, { 0x9a, 0xd7, 0x13, 0x89, 0x3c, 0xeb },
	{ 0x9c, 0xd2, 0x08, 0x94, 0x2b, 0xf9 }, { 0x9e, 0xd1, 0x01, 0x9f, 0x26, 0xf7 },
	{ 0xa0, 0xf0, 0xe6, 0x46, 0xbd, 0x4d }, { 0xa2, 0xf3, 0xef, 0x4d, 0xb0, 0x43 },
	{ 0xa4, 0xf6, 0xf4, 0x50, 0xa7, 0x51 }, { 0xa6, 0xf5, 0xfd, 0x5b, 0xaa, 0x5f },
	{ 0xa8, 0xfc, 0xc2, 0x6a, 0x89, 0x75 }, { 0xaa, 0xff, 0xcb, 0x61, 0x84, 0x7b },
	{ 0xac, 0xfa, 0xd0, 0x7c, 0x93, 0x69 }, { 0xae, 0xf9, 0xd9, 0x77, 0x9e, 0x67 },
	{ 0xb0, 0xe8, 0xae, 0x1e, 0xd5, 0x3d }, { 0xb2, 0xeb, 0xa7, 0x15, 0xd8, 0x33 },
	{ 0xb4, 0xee, 0xbc, 0x08, 0xcf, 0x21 }, { 0xb6, 0xed, 0xb5, 0x03, 0xc2, 0x2f },
	{ 0xb8, 0xe4, 0x8a, 0x32, 0xe1, 0x05 }, { 0xba, 0xe7, 0x83, 0x39, 0xec, 0x0b },
	{ 0xbc, 0xe2, 0x98, 0x24, 0xfb, 0x19 }, { 0xbe, 0xe1, 0x91, 0x2f, 0xf6, 0x17 },
	{ 0xc0, 0xa0, 0x4d, 0x8d, 0xd6, 0x76 }, { 0xc2, 0xa3, 0x44, 0x86, 0xdb, 0x78 },
	{ 0xc4, 0xa6, 0x5f, 0x9b, 0xcc, 0x6a }, { 0xc6, 0xa5, 0x56, 0x90, 0xc1, 0x64 },
	{ 0xc8, 0xac, 0x69, 0xa1, 0xe2, 0x4e }, { 0xca, 0xaf, 0x60, 0xaa, 0xef, 0x40 },
	{ 0xcc, 0xaa, 0x7b, 0xb7, 0xf8, 0x52 }, { 0xce, 0xa9, 0x72, 0xbc, 0xf5, 0x5c },
	{ 0xd0, 0xb8, 0x05, 0xd5, 0xbe, 0x06 }, { 0xd2, 0xbb, 0x0c, 0xde, 0xb3, 0x08 },
	{ 0xd4, 0xbe, 0x17, 0xc3, 0xa4, 0x1a }, { 0xd6, 0xbd, 0x1e, 0xc8, 0xa9, 0x14 },
	{ 0xd8, 0xb4, 0x21, 0xf9, 0x8a, 0x3e }, { 0xda, 0xb7, 0x28, 0xf2, 0x87, 0x30 },
	{ 0xdc, 0xb2, 0x33, 0xef, 0x90, 0x22 }, { 0xde, 0xb1, 0x3a, 0xe4, 0x9d, 0x2c },
	{ 0xe0, 0x90, 0xdd, 0x3d, 0x06, 0x96 }, { 0xe2, 0x93, 0xd4, 0x36, 0x0b, 0x98 },
	{ 0xe4, 0x96, 0xcf, 0x2b, 0x1c, 0x8a }, { 0xe6, 0x95, 0xc6, 0x20, 0x11, 0x84 },
	{ 0xe8, 0x9c, 0xf9, 0x11, 0x32, 0xae }, { 0xea, 0x9f, 0xf0, 0x1a, 0x3f, 0xa0 },
	{ 0xec, 0x9a, 0xeb, 0x07, 0x28, 0xb2 }, { 0xee, 0x99, 0xe2, 0x0c, 0x25, 0xbc },
	{ 0xf0, 0x88, 0x95, 0x65, 0x6e, 0xe6 }, { 0xf2, 0x8b, 0x9c, 0x6e, 0x63, 0xe8 },
	{ 0xf4, 0x8e, 0x87, 0x73, 0x74, 0xfa }, { 0xf6, 0x8d, 0x8e, 0x78, 0x79, 0xf4 },
	{ 0xf8, 0x84, 0xb1, 0x49, 0x5a, 0xde }, { 0xfa, 0x87, 0xb8, 0x42, 0x57, 0xd0 },
	{ 0xfc, 0x82, 0xa3, 0x5f, 0x40, 0xc2 }, { 0xfe, 0x81, 0xaa, 0x54, 0x4d, 0xcc },
	{ 0x1b, 0x9b, 0xec, 0xf7, 0xda, 0x41 }, { 0x19, 0x98, 0xe5, 0xfc, 0xd7, 0x4f },
	{ 0x1f, 0x9d, 0xfe, 0xe1, 0xc0, 0x5d }, { 0x1d, 0x9e, 0xf7, 0xea, 0xcd, 0x53 },
	{ 0x13, 0x97, 0xc8, 0xdb, 0xee, 0x79 }, { 0x11, 0x94, 0xc1, 0xd0, 0xe3, 0x77 },
	{ 0x17, 0x91, 0xda, 0xcd, 0xf4, 0x65 }, { 0x15, 0x92, 0xd3, 0xc6, 0xf9, 0x6b },
	{ 0x0b, 0x83, 0xa4, 0xaf, 0xb2, 0x31 }, { 0x09, 0x80, 0xad, 0xa4, 0xbf, 0x3f },
	{ 0x0f, 0x85, 0xb6, 0xb9, 0xa8, 0x2d }, { 0x0d, 0x86, 0xbf, 0xb2, 0xa5, 0x23 },
	{ 0x03, 0x8f, 0x80, 0x83, 0x86, 0x09 }, { 0x01, 0x8c, 0x89, 0x88, 0x8b, 0x07 },
	{ 0x07, 0x89, 0x92, 0x95, 0x9c, 0x15 }, { 0x05, 0x8a, 0x9b, 0x9e, 0x91, 0x1b },
	{ 0x3b, 0xab, 0x7c, 0x47, 0x0a, 0xa1 }, { 0x39, 0xa8, 0x75, 0x4c, 0x07, 0xaf },
	{ 0x3f, 0xad, 0x6e, 0x51, 0x10, 0xbd }, { 0x3d, 0xae, 0x67, 0x5a, 0x1d, 0xb3 },
	{ 0x33, 0xa7, 0x58, 0x6b, 0x3e, 0x99 }, { 0x31, 0xa4, 0x51, 0x60, 0x33, 0x97 },
	{ 0x37, 0xa1, 0x4a, 0x7d, 0x24, 0x85 }, { 0x35, 0xa2, 0x43, 0x76, 0x29, 0x8b },
	{ 0x2b, 0xb3, 0x34, 0x1f, 0x62, 0xd1 }, { 0x29, 0xb0, 0x3d, 0x14, 0x6f, 0xdf },
	{ 0x2f, 0xb5, 0x26, 0x09, 0x78, 0xcd }, { 0x2d, 0xb6, 0x2f, 0x02, 0x75, 0xc3 },
	{ 0x23, 0xbf, 0x10, 0x33, 0x56, 0xe9 }, { 0x21, 0xbc, 0x19, 0x38, 0x5b, 0xe7 },
	{ 0x27, 0xb9, 0x02, 0x25, 0x4c, 0xf5 }, { 0x25, 0xba, 0x0b, 0x2e, 0x41, 0xfb },
	{ 0x5b, 0xfb, 0xd7, 0x8c, 0x61, 0x9a }, { 0x59, 0xf8, 0xde, 0x87, 0x6c, 0x94 },
	{ 0x5f, 0xfd, 0xc5, 0x9a, 0x7b, 0x86 }, { 0x5d, 0xfe, 0xcc, 0x91, 0x76, 0x88 },
	{ 0x53, 0xf7, 0xf3, 0xa0, 0x55, 0xa2 }, { 0x51, 0xf4, 0xfa, 0xab, 0x58, 0xac },
	{ 0x57, 0xf1, 0xe1, 0xb6, 0x4f, 0xbe }, { 0x55, 0xf2, 0xe8, 0xbd, 0x42, 0xb0 },
	{ 0x4b, 0xe3, 0x9f, 0xd4, 0x09, 0xea }, { 0x49, 0xe0, 0x96, 0xdf, 0x04, 0xe4 },
	{ 0x4f, 0xe5, 0x8d, 0xc2, 0x13, 0xf6 }, { 0x4d, 0xe6, 0x84, 0xc9, 0x1e, 0xf8 },
	{ 0x43, 0xef, 0xbb, 0xf8, 0x3d, 0xd2 }, { 0x41, 0xec, 0xb2, 0xf3, 0x30, 0xdc },
	{ 0x47, 0xe9, 0xa9, 0xee, 0x27, 0xce }, { 0x45, 0xea, 0xa0, 0xe5, 0x2a, 0xc0 },
	{ 0x7b, 0xcb, 0x47, 0x3c, 0xb1, 0x7a }, { 0x79, 0xc8, 0x4e, 0x37, 0xbc, 0x74 },
	{ 0x7f, 0xcd, 0x55, 0x2a, 0xab, 0x66 }, { 0x7d, 0xce, 0x5c, 0x21, 0xa6, 0x68 },
	{ 0x73, 0xc7, 0x63, 0x10, 0x85, 0x42 }, { 0x71, 0xc4, 0x6a, 0x1b, 0x88, 0x4c },
	{ 0x77, 0xc1, 0x71, 0x06, 0x9f, 0x5e }, { 0x75, 0xc2, 0x78, 0x0d, 0x92, 0x50 },
	{ 0x6b, 0xd3, 0x0f, 0x64, 0xd9, 0x0a }, { 0x69, 0xd0, 0x06, 0x6f, 0xd4, 0x04 },
	{ 0x6f, 0xd5, 0x1d, 0x72, 0xc3, 0x16 }, { 0x6d, 0xd6, 0x14, 0x79, 0xce, 0x18 },
	{ 0x63, 0xdf, 0x2b, 0x48, 0xed, 0x32 }, { 0x61, 0xdc, 0x22, 0x43, 0xe0, 0x3c },
	{ 0x67, 0xd9, 0x39, 0x5e, 0xf7, 0x2e }, { 0x65, 0xda, 0x30, 0x55, 0xfa, 0x20 },
	{ 0x9b, 0x5b, 0x9a, 0x01, 0xb7, 0xec }, { 0x99, 0x58, 0x93, 0x0a, 0xba, 0xe2 },
	{ 0x9f, 0x5d, 0x88, 0x17, 0xad, 0xf0 }, { 0x9d, 0x5e, 0x81, 0x1c, 0xa0, 0xfe },
	{ 0x93, 0x57, 0xbe, 0x2d, 0x83, 0xd4 }, { 0x91, 0x54, 0xb7, 0x26, 0x8e, 0xda },
	{ 0x97, 0x51, 0xac, 0x3b, 0x99, 0xc8 }, { 0x95, 0x52, 0xa5, 0x30, 0x94, 0xc6 },
	{ 0x8b, 0x43, 0xd2, 0x59, 0xdf, 0x9c }, { 0x89, 0x40, 0xdb, 0x52, 0xd2, 0x92 },
	{ 0x8f, 0x45, 0xc0, 0x4f, 0xc5, 0x80 }, { 0x8d, 0x46, 0xc9, 0x44, 0xc8, 0x8e },
	{ 0x83, 0x4f, 0xf6, 0x75, 0xeb, 0xa4 }, { 0x81, 0x4c, 0xff, 0x7e, 0xe6, 0xaa },
	{ 0x87, 0x49, 0xe4, 0x63, 0xf1, 0xb8 }, { 0x85, 0x4a, 0xed, 0x68, 0xfc, 0xb6 },
	{ 0xbb, 0x6b, 0x0a, 0xb1, 0x67, 0x0c }, { 0xb9, 0x68, 0x03, 0xba, 0x6a, 0x02 },
	{ 0xbf, 0x6d, 0x18, 0xa7, 0x7d, 0x10 }, { 0xbd, 0x6e, 0x11, 0xac, 0x70, 0x1e },
	{ 0xb3, 0x67, 0x2e, 0x9d, 0x53, 0x34 }, { 0xb1, 0x64, 0x27, 0x96, 0x5e, 0x3a },
	{ 0xb7, 0x61, 0x3c, 0x8b, 0x49, 0x28 }, { 0xb5, 0x62, 0x35, 0x80, 0x44, 0x26 },
	{ 0xab, 0x73, 0x42, 0xe9, 0x0f, 0x7c }, { 0xa9, 0x70, 0x4b, 0xe2, 0x02, 0x72 },
	{ 0xaf, 0x75, 0x50, 0xff, 0x15, 0x60 }, { 0xad, 0x76, 0x59, 0xf4, 0x18, 0x6e },
	{ 0xa3, 0x7f, 0x66, 0xc5, 0x3b, 0x44 }, { 0xa1, 0x7c, 0x6f, 0xce, 0x36, 0x4a },
	{ 0xa7, 0x79, 0x74, 0xd3, 0x21, 0x58 }, { 0xa5, 0x7a, 0x7d, 0xd8, 0x2c, 0x56 },
	{ 0xdb, 0x3b, 0xa1, 0x7a, 0x0c, 0x37 }, { 0xd9, 0x38, 0xa8, 0x71, 0x01, 0x39 },
	{ 0xdf, 0x3d, 0xb3, 0x6c, 0x16, 0x2b }, { 0xdd, 0x3e, 0xba, 0x67, 0x1b, 0x25 },
	{ 0xd3, 0x37, 0x85, 0x56, 0x38, 0x0f }, { 0xd1, 0x34, 0x8c, 0x5d, 0x35, 0x01 },
	{ 0xd7, 0x31, 0x97, 0x40, 0x22, 0x13 }, { 0xd5, 0x32, 0x9e, 0x4b, 0x2f, 0x1d },
	{ 0xcb, 0x23, 0xe9, 0x22, 0x64, 0x47 }, { 0xc9, 0x20, 0xe0, 0x29, 0x69, 0x49 },
	{ 0xcf, 0x25, 0xfb, 0x34, 0x7e, 0x5b }, { 0xcd, 0x26, 0xf2, 0x3f, 0x73, 0x55 },
	{ 0xc3, 0x2f, 0xcd, 0x0e, 0x50, 0x7f }, { 0xc1, 0x2c, 0xc4, 0x05, 0x5d, 0x71 },
	{ 0xc7, 0x29, 0xdf, 0x18, 0x4a, 0x63 }, { 0xc5, 0x2a, 0xd6, 0x13, 0x47, 0x6d },
	{ 0xfb, 0x0b, 0x31, 0xca, 0xdc, 0xd7 }, { 0xf9, 0x08, 0x38, 0xc1, 0xd1, 0xd9 },
	{ 0xff, 0x0d, 0x23, 0xdc, 0xc6, 0xcb }, { 0xfd, 0x0e, 0x2a, 0xd7, 0xcb, 0xc5 },
	{ 0xf3, 0x07, 0x15, 0xe6, 0xe8, 0xef }, { 0xf1, 0x04, 0x1c, 0xed, 0xe5, 0xe1 },
	{ 0xf7, 0x01, 0x07, 0xf0, 0xf2, 0xf3 }, { 0xf5, 0x02, 0x0e, 0xfb, 0xff, 0xfd },
	{ 0xeb, 0x13, 0x79, 0x92, 0xb4, 0xa7 }, { 0xe9, 0x10, 0x70, 0x99, 0xb9, 0xa9 },
	{ 0xef, 0x15, 0x6b, 0x84, 0xae, 0xbb }, { 0xed, 0x16, 0x62, 0x8f, 0xa3, 0xb5 },
	{ 0xe3, 0x1f, 0x5d, 0xbe, 0x80, 0x9f }, { 0xe1, 0x1c, 0x54, 0xb5, 0x8d, 0x91 },
	{ 0xe7, 0x19, 0x4f, 0xa8, 0x9a, 0x83 }, { 0xe5, 0x1a, 0x46, 0xa3, 0x97, 0x8d }
}; 
/**< Прерачунате вредности множења са 2, 3, А, B, C, D у Галоаовом пољу. */

static const UInt32 ROUND_CONSTANT[] = { 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000,
0x40000000, 0x80000000, 0x1b000000, 0x36000000, 0x6c000000, 0xd8000000,
0xab000000, 0x4d000000, 0x9a000000 }; 
/**< Константа која осигурава сигурност експанзије кључа*/

static const UInt32 CRC32_TABLE[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
}; 
/**< Прерачунате вредности које се користе код провере исправности шифрованог датотеке датим кључем. */

/**
 * @brief Претвара низ 4 бајта у #UInt32.
 * @param byte [in] Низ 4 бајта (тип #UChar).
 * @return Враћа број типа #UInt32 чија је представа @p byte
 * @code{.c}
 * UChar byte[4] = {\x0, \x1, \x2, \x3}
 * UInt32 t = UCharToUint32(byte); // t добија вредност 0x0123
 * @endcode
 */
UInt32 UCharToUInt32(const UChar byte[]);

/**
 * @brief Врши операцију еклузивне дисјункције блока бајтова величине #STATE_SIZE и кључа.
 *
 * Добијени резултат се смешта у променљиву  @p state.
 * @param state [in/out] Матрица 4 * 4 бајтова који се XOR-ује са кључем.
 * @param key [in] Део кључа са којим се XOR-ује.
 * @code{.c}
 *	UChar state[4][4] = {0};
 *  UInt32 key[4] = {0};
 *  AddRoundKey(state, key); // XOR-ује state са кључем чије су све вредности 0
 * @endcode
 */
void AddRoundKey(UChar state[][4], const  UInt32 key[]);

/**
 * @brief Мења вредност сваког појединачног бајта из @p state одговарајућом вредношћу из #S_BOX
 * @param state [in/out]  Матрица 4 *4 бајтова над чијим вредностима се врши замена.
 * @code{.c}
 *  UChar state[4][4] = {0};
 *  SubBytes(state); Замењује сваки бајт из state са одговарајућом вредношћу из S_BOX
 * @endcode
 */
void SubBytes(UChar state[][4]);

/**
* @brief Мења вредност сваког појединачног бајта из @p state одговарајућом вредношћу из #INVS_BOX
* @param state [in/out]  Матрица 4 *4 бајтова над чијим вредностима се врши замена.
* @code{.c}
*  UChar state[4][4] = {0};
*  SubBytes(state); Замењује сваки бајт из state са одговарајућом вредношћу из INVS_BOX
* @endcode
*/
void InvSubBytes(UChar state[][4]);

/**
 * @brief Ротира бајтове у врстама, у i-тој врсти за i места улево.
 *
 * Матрица бајтова @p state 4 * 4  трансформише се у нову тако да се свака i-та врста ротира улево i места.
 * @param state [in/out] Матрица бајтова у којој се бајтови по врстама ротирају.
 * @code{.c}
 *  Uchar state[4][4] = {{0}, {1}, {2}, {3}}
 * ShiftRows(state); // state[4][4] = {{0}, {0, 0, 0, 1}, {0, 0, 2, 0}, {0, 3, 0, 0}}
 * @endcode
 */
void ShiftRows(UChar state[][4]);

/**
* @brief Ротира бајтове у врстама, у i-тој врсти за i места удесно.
*
* Матрица бајтова @p state 4 * 4  трансформише се у нову тако да се свака i-та врста ротира удесно i места.
* @param state [in/out] Матрица бајтова у којој се бајтови по врстама ротирају.
* @code{.c}
*  Uchar state[4][4] = {{0}, {1}, {2}, {3}}
* ShiftRows(state); // state[4][4] = {{0}, {0, 1, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 3}}
* @endcode
*/
void InvShiftRows(UChar state[][4]);

/**
 * @brief Миксује колоне матрице бајтова @p state.
 * 
 * Миксовање се врши множењем са одговарајућом матрицом у Галоаовом пољу.
 * @param state [in/out] Матрица бајтова у којој се вршим миксовање колона.
 * @code{.c}
 *  Uchar state[4][4] = {{0}, {1}, {2}, {3}};
 * MixColumns(state); // state = {{2}, {7}, {0}, {5}}, матрица која се добија миксовањем колона.
 * @endcode
 */
void MixColumns(UChar state[][4]);

/**
 * @brief Инверзно миксује колоне матрице бајтова @p state.
 *
 * Инверзно миксовање се врши множењем са одговарајућом матрицом у Галоаовом пољу. 
 * Крајњи резултат је матрица која је првобитно била миксована.
 * @param state [in/out] Матрица бајтова у којој се вршим миксовање колона.
 * @code{.c}
 *  UChar state[4][4] = { { 2 }, { 7 }, { 0 }, { 5 } };
 * InvMixColumns(state); // state = {{0}, {1}, {2}, {3}}, матрица која се добија миксовањем колона.
 * @endcode
 */
void InvMixColumns(UChar state[][4]);

/**
 * @brief 1-бајтна кружна  ротација 4-бајтне(#UInt32) речи улево.
 * 
 * @param wordPt [in/out] Показивач на #UInt32 реч која се ротира.
 * @code{.c}
 *  UInt32 t= 0x01;
 *  RotWor(&t); // t = 0x0100;
 * @endcode
 */
void RotWord(UInt32 *wordPt);

/**
 * @brief Замена сваког бајта 4-бајтне речи @p word одговарајућим бајтом из #S_BOX
 *
 * @param word [in] 4-бајтна реч типа #UInt32 код које се мењају бајтови.
 * @return 4-бајтна реч која се добија заменом бајтова из @p word 
 * @code{.c}
 *  UInt32 t = 0x1;
 *  t = SubWord(t); // t = 0x6363637c 
 * @endcode
 */
UInt32 SubWord(const UInt32 word);

/**
 * @brief Развија кључ @p key у низ 4-бајтних кључева @p w.
 *
 * Добијених 4-бајтних кључева има колико и (рунди шифорвања + 1) * 4. Рунди шифровања има у зависности од величине кључа.
 * Фунцкија враћа вредност int која указује на тип грешке (ако га има).
 * @param key [in] Кључ који се развија.
 * @param keySize [in] Величина кључа који се развија.
 * @param w [out] Показивач на низ експандованих кључева од кључа @p key
 * @return @c -1 ако нема довољно меморије за експанзију кључа. \n
 * @c 1 aко је прослеђена лоша дужина кључа.\n
 * @c 0 aко је све протекло у реду.
 * @code{.c}
 *  UChar keyIn[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
 *  UInt32 *key;
 *  KeyExpansion(keyIn, &key, 128); // Развија 128-битни keyIn кључ keyIn.
 * @endcode
 */
int KeyExpansion(const UChar key[], UInt32 **w, const int keySize);

/**
 * @brief Шифрује АЕС-ом низ бајтова величине #STATE_SIZE задат са @p in помоћу низа кључева @p key (добијених #KeyExpansion) 
 * и уписује у @p out.
 *
 * @p in Мора бити величине бар #STATE_SIZE, @p out мора имати алоцирану меморију изван функције. 
 * @param in [in] Низ бајтова величине #STATE_SIZE који се шифрује АЕС-ом.
 * @param out [out] Низ шифрованих бајтова величине #STATE_SIZE
 * @param key [in] Низ експандованих кључева.
 * @param keySize [in] Величина кључа којим се шифрује.
 * @code{.c}
 *  UChar out[STATE_SIZE], in[STATE_SIZE] = {0},
 *  keyIn[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
 *  UInt32 *key;
 *  KeyExpansion(keyIn, &key, 128);
 *  EncryptState(in, out, key, 128); // out је низ шифрованих бајтова in кључем key.
 * @endcode
 * @warning Простор од #STATE_SIZE за @p out мора бити алоциран изван функције.
 */
void EncryptState(const UChar in[], UChar out[], const UInt32 key[], const int keySize);

/**
 * @brief Дешифрује АЕС-ом низ бајтова величине #STATE_SIZE задат са @p in помоћу низа кључева @p key (добијених #KeyExpansion)
 * и уписује у @p out.
 *
 * @p in Мора бити величине бар #STATE_SIZE, @p out мора имати алоцирану меморију изван функције.
 * @param in [in] Низ бајтова величине #STATE_SIZE који се дешифрује АЕС-ом.
 * @param out [out] Низ дешифрованих бајтова величине #STATE_SIZE
 * @param key [in] Низ експандованих кључева.
 * @param keySize [in] Величина кључа којим се дешифрује.
 * @code{.c}
 *  UChar out[STATE_SIZE], in[STATE_SIZE] = {0},
 *  keyIn[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
 *  UInt32 *key;
 *  KeyExpansion(keyIn, &key, 128);
 *  DecryptState(in, out, key, 128); // out је низ дешифрованих бајтова in кључем key.
 * @endcode
 * @warning Простор од #STATE_SIZE за @p out мора бити алоциран изван функције.
 */
void DecryptState(const UChar in[], UChar out[], const UInt32 key[], const int keySize);


/**
 * @brief Враћа величину датотеке имена @p name која се налази у истом фолдеру у којем је програм.
 * @param name [in] Име датотеке чија се величина тражи.
 * @return Величина датотеке у бајтовима.
 * @code{.c}
 *  UChar *name = "Ulaz.in";
 *  UInt32 size = SizeOfFile(name); // vraca velicinu datoteke sa imenom name
 * @endcode
 * @warning Величина датотеке не сме бити већа од 4GB. Ако дође до грешке при читању датотеке, непознат је резултат.
 */
UInt32 SizeOfFile(const UChar *name);

/**
 * @brief Чита из датотеке @p f блок бајтова #STATE_SIZE и смешта у @p state.
 * 
 * Ако је број преосталих бајтова до краја датотеке (@p sizeToEnd) мањи од #STATE_SIZE, прочитаће само толико бајтова 
 * и уписати их у @p state. Остатак се попуњава нулама. @p sizeToEnd је показивач на величину бајтова колико се чита. Његов број 
 * смањује се за #STATE_SIZE или ако је мањи од #STATE_SIZE поставља се на @c 0. Низ @p state мора имати бар 16 бајтова меморије.
 * @param f [in/out] Показивач на датотеку из које се бајтови читају.
 * @param state [out] Низ бајтова (#UChar) у који се смештају прочитани бајтови.
 * @param sizeToEnd [in/out] Величина којом се одређује колико се бајтова чита (и чија вредност се умањује за број прочитаних бајтова).
 * @return @c 1 aко је све добро протекло.\n 
           @c 0 ако је дошло до грешке при читању датотеке. 
 * @code{.c}
 *  FILE *in = fopen("Ulaz.in", "r");
    UChar state[STATE_SIZE];
	UInt32 sizeToEnd = 10;
	if (!ReadData(in, state, &sizeToEnd)) 
	printf("Greska pri citanju\n");
 * @endcode
 */
int ReadData(FILE *f, UChar state[], UInt32 *sizeToEnd);
/**
 * @brief Пише у датотеку @p f блок бајтова #STATE_SIZE из @p state.
 * @param f [in/out] Показивач на датотеку у који се бајтови пишу.
 * @param state [in] Низ бајтова (#UChar) који се уписују.
 * @return @p 1 aко је све добро протекло.\n 
           @c 0 ако је дошло до грешке при писању датотеке.
 * @code{.c}
 * FILE *out = fopen("Izlaz.out", "w");
   UChar state[STATE_SIZE] = {0};	
   if (!WriteData(out, state)) // pise u datoteku Izlaz.out STATE_SIZE bajtova ciji su svi bitovi 0
   printf("Greska pri pisanju\n");
 * @endcode
 */
int WriteData(FILE *f, const UChar state[]);


/**
 * @brief Преводи 4-бајтни број типа #UInt32 у низ од 16 бајтова.
 *
 * Виши бајтови броја (они који имају већу тежину у броју) иду на ниже индексе у низу. 
 * Остали бајтови се попуњавају са нулама.
 * Низ мора имати меморију од бар #STATE_SIZE бајтова. Најнижи бајт броја се ставља у @p state[#STATE_SIZE-1]
 * @param num [in] Број који пребацујемо у низ бајтова.
 * @param state [in/out] Низ бајтова у који се пребацује број.
 * @code{.c}
 *  UInt32 t = 1;
	UChar state[STATE_SIZE];
	UInt32ToState(t, state); // poslednji bajt state je 1, svi ostali su 0
 * @endcode
 * @note Функција је неопходна јер се не зна да ли рачунар на ком се покреће програм има LITTLE-ENDIAN или BIG-ENDIAN.
 */
void UInt32ToState(const UInt32 num, UChar state[]);

/**
 * @brief Преводи низ од 16 бајтова у број од 4 бајта (#UInt32).
 *
 * Бајтови са нижим индексима у низу иду у више бајтове броја (они који имају већу тежину у броју).
 * Најнижи бајт броја је у @p state[#STATE_SIZE-1]. Највиши бајт броја је у @p state[#STATE_SIZE-4].
 * @param state [in/out] Низ бајтова у који се пребацује број.
 * @return 4-бајтни број који се добија из @p state.
 * @code{.c}
 *  UInt32 t;
   UChar state[STATE_SIZE] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
   t = StateToUInt32(state) // t = 1
 * @endcode
 * @note Функција је неопходна јер се не зна да ли рачунар на ком се покреће програм има LITTLE-ENDIAN или BIG-ENDIAN.
 */
// pretvara state u UInt32
UInt32 StateToUInt32(const UChar state[]);

/**
 * @brief Прави име шифроване датотеке од имена датотеке који треба да шифрује
 *
 * Додаје #CRYPT_TEXT на крај имена шифроване датотеке @p inFileName. Ако је име путање које би се добило веће од максималне дужине имена путање коју 
 * @c WINDOWS може да прими (#MAX_FILE_PATH), на крај имена додаје #CRYPT_TEXT преко онолико карактера колико треба да се дода #CRYPT_TEXT, 
 * а да не пређе ограничење у @c WINDOWS.
 * @param inFileName [in] Име улазне датотеке који се шифрује.
 * @return @p NULL ако нема довољно меморије. \n
           Иначe враћа име шифроване датотеке.
 * @code{.c}
    char *t = "tata";
	t = CypherFileName(t); // t postaje tata.crypt;
   @endcode
 */
UChar *CypherFileName(const UChar *inFileName);

/** 
 * @brief Враћа име датотеке које ће имати након што се дешифрује.
 * 
 * Проверава да ли постоји датотека са истим именом као @p *inFileName. Ако постоји додаје насумичан број на почетак 
 * док дато име не буде постојало. Кад дужина путање до имена фајла са додатим насумичним бројем пређе дужину #MAX_FILE_PATH
 * додаје се број тако да се крај имена губи. @p *inFileName мора бити алоциран динамички.
 * @param inFileName [in/out] Име датотеке који се дешифрује.
 * @return @c 0 aко је све добро протекло.\n
           @c 1 aко нема довољно меморије. \n
		   @c 2 ако је путања неисправна (предугачко име прослеђено).
 * @code{.c}
    UChar *t = (UChar*)malloc(5);
	t[0] = '\0';
	strcat(t, "tata");
	DeCypherFileName(&t); 
   @endcode
 */
int DeCypherFileName(UChar **inFileName);

/** 
 * @brief Враћа вредност CRC-а датог блока @p	state од #STATE_SIZE бајтова и @p crc.
 * @param crc [in] Вредност са којом се ради #CRC32
 * @param state [in] Блок бајтова који се CRC-ује.
 * @return Новодобијена вредност CRC функције након примене CRC-а на @p crc и @p state
 * @code{.c}
    UInt32 crc = 0;
	UChar state[STATE_SIZE] = {0};
	crc = CRC32(crc, state); //		crc = 0xecbb4b55	
   @endcode
 */
UInt32 CRC32(UInt32 crc, const  UChar state[]);

/**
 * @brief Врши проверу #CRC32 функцијом, да ли је дошло до нежељених измена у шифрованој датотеци @p in
 * @param in [in/out] Отворена улазна датотеке који је отворен за читање бинарних датоека 
    код којег желимо да проверимо да ли је дошло до нежељених измена.
  Почетна позиција за читање мора бити на почетку датотке.
 * @param key [in] Развијени облик кључа којим је шифрована датотека @p in.
 * @param keySize [in] Величина кључа којим је шифрована датотека @p in.
 * @return 
 *  0 ако није дошло до нежељених измена у шифрованој датотеци @p in. \n
 *  1 ако је дошло до нежељених измена у шифрованој датотеци @p in.
 * @code{.c}
 *  FILE *in = fopen("ulaz.in.crypt", "rb");
 *  UChar keyIn[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
 *	UInt32 *key = NULL;
 *	KeyExpansion(keyIn, &key, strlen(keyIn) * 8);
 *	if (CRCCheck(in, key, strlen(keyIn) * 8) == 0)
 *		printf("Dobro sifrovana");
 *	else printf("Lose");
 *	fclose(in);
 * @endcode
 * @see #KeyExpansion
 */
int CRCCheck(FILE *in, const UInt32 key[], const int keySize);

/** 
 * @brief Шифрује датотеку са именом @p *inFileName помоћу кључа @p keyIn, величине @p keySize.
 *
 * Име датотеке, @p *inFileName мора бити алоцирано на heap-у. Кључ @p keyIn којим се шифрује мора бити величине 
   128, 192 или 256 битова. Величина кључа се прослеђује у @p keySize. 
   Име датотеке која се добија шифровањем се прослеђује у @p *inFileName. Датотека која се шифрује мора бити мања од @c 4GB.
 * @param inFileName [in/out] Име датотеке која се шифрује и име под којим је шифрована.
 * @param keyIn [in] Кључ којим се шифрује датотека
 * @param keySize [in] Величина кључа којим се шифрује датотека.
 * @return
     0 aко је успешно шифрована датотека \n
	 1 aко је дошло до грешке при читању из датотеке (непостојећа датотека, грешке у систему).\n
	 2 aко је дошло до грешке при писању у датотеку.\n
	 3 aко нема довољно меморије. \n
	 4 ако дужина имена није добра (већа од максималне дозвољене у @c WINDOWS-у). \n
	 5 ако дужина кључа није добра. \n
  *@code{.c}
	UChar *inputName, key[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
	inputName = (UChar*)malloc(256);
	strcpy(inputName, "ulaz.in");
	CypherAES(&inputName, key, strlen(key) * 8); // sifruje datoteku ulaz.in pomocu kljuca key
  *@endcode
  *@warning Величина датотеке која се шифрује мора бити мања од @c 4GB.
 */
int CypherAES(UChar **inFileName, const UChar keyIn[], const int keySize);


/**
  * @brief Дешифрује датотеку са именом @p *inFileName помоћу кључа @p keyIn, величине @p keySize.
  *
  * Име датотеке, @p *inFileName мора бити алоцирано на heap-у. Кључ @p keyIn којим се дешифрује мора бити величине
   128, 192 или 256 битова. Величина кључа се прослеђује у @p keySize.
   Име датотеке која се добија дешифровањем се прослеђује у @p *inFileName. Датотека која се дешифрује мора бити мања од @c 4GB 
  (не укључујући заглавље).
  * @param inFileName [in/out] Име датотеке која се дешифрује и име под којим је дешифрована.
  * @param keyIn [in] Кључ којим се дешифрује датотека
  * @param keySize [in] Величина кључа којим се дешифрује датотека.
  * @return
     0 aко је успешно дешифрована датотека \n
	 1 aко је дошло до грешке при читању из датотеке (непостојећа датотека, грешке у систему).\n
	 2 aко је дошло до грешке при писању у датотеку.\n
	 3 aко нема довољно меморије. \n
	 4 ако дужина имена није добра (већа од максималне дозвољене у @c WINDOWS-у). \n
	 5 ако дужина кључа није добра. \n
	 6 ако није добро шифрована датотека уз помоћ кључа @p keyIn
  *@code{.c}
   UChar *inputName, key[] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
	inputName = (UChar*)malloc(256);
	strcpy(inputName, "ulaz.in.crypt");
	DecypherAES(&inputName, key, strlen(key) * 8); // datoteka ulaz.in.crypt se desifruje pomocu kljuca key
  *@endcode
  *@warning Величина датотеке која се шифрује мора бити мања од @c 4GB (искључујући заглавља).
 */
int DecypherAES(UChar **inFileName, const UChar keyIn[], const int keySize);

#endif